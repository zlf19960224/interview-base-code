<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #box {
            border: 1px solid #000;
            width: 100px;
            height: 100px;
            position: absolute;
        }
    </style>
</head>

<body>
    <div id="box">

    </div>
    <!-- <button id="btn">
        <p>
            111
        </p>
    </button> -->
    <!-- <script src="express.js"> -->
    <!-- </script> -->

    <script>
        /**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
        /**
         * @param {ListNode[]} lists
         * @return {ListNode}
         */

        //柯里化
        // var m=0;
        // function add(){
        //     var args=Array.prototype.splice.call(arguments,0);
        //     m+=parseInt(args);
        //     add.value=m;
        //     return add;
        // }
        // // console.log
        // console.log(add(11111)(22222)(33333)(44444).value);
        // function request(number) {
        //     const time = Math.random() * 1000;
        //     return new Promise((resolve, reject) => {
        //             resolve(number);

        //     });
        // }
        // for (let i = 0; i < 10; i++) {
        //     request(i).then(res => console.log(res));
        // }
        // function request(number) {
        //     const time = Math.random() * 1000;
        //     return new Promise((resolve, reject) => {
        //         setTimeout(() => {
        //             resolve(number);
        //         }, time);
        //     });
        // }
        // var arr=[];
        // for (let i = 0; i < 10; i++) {
        //    arr.push(request(i));
        // }
        // (async ()=>{
        //     for(let req of arr){
        //         console.log(await req)
        //     }
        // })()

        // console.log(('abc345efgabcab').replace( '45','[5]'));
        // console.log(null instanceof Object);
        //false

        // const arr=[1, 3, 9, 6, 10, 7, 3, 3, 6, 20];
        // let newArr=Array.from(new Set([...arr])).sort((a,b)=>{return a-b;})
        //     console.log(newArr);
        // function createNew(newObj){
        //     //创建新对象并链接原型链到newObj上
        //     var obj=Object.create(newObj.prototype);
        //     //获取多参
        //     var arg=Array.prototype.slice.call(arguments,1);
        //     //执行obj
        //     let result=newObj.apply(obj,arg);
        //     return (typeof result==="object")? result : obj;
        // }   
        // function createNew(newObj){
        //     let obj=new Object()
        //     let args=Array.prototype.slice.call(arguments,1)
        //     let con=Array.prototype.shift.call(arguments)
        //     obj.__proto__=con.prototype;
        //     let result = con.apply(obj,args)
        //     return (typeof result==='object')?result:obj;
        // }
        // let obj={
        //     v1:"1",
        //     v2:"2",
        //     v3:"3"
        // }
        // console.log(obj.__proto__===obj);
        // var a=2;
        // var func=(function(){
        //     var a=3;
        //     return function(){
        //         a++;
        //         alert(a)
        //     }
        // })();
        // func()
        // func()
        //    var str = 'AAAABBBBCCCCCDDDDD';
        //    function m(str){
        //     var arr = Array.prototype.slice.call(str);
        //     var k=arr.reduce((result,current)=>{
        //         if(result.indexOf(current)==-1){
        //             result.push(current);
        //         }
        //         return result;
        //     },[]);
        //     return k;
        //    }
        //   console.log( m(str).join(""));
        // var str = 'AAAABBBBCCCCCDDDDD';
        // function m(str){
        //     var arr = Array.prototype.slice.call(str);
        //     var newStr=Array.from(new Set([...arr])).join("");
        //     return newStr;
        // }
        // console.log(m(str))
        // var express = require('express');
        // var app = express();
        // app.listen(3000, function () {
        //     console.log('listen 3000...');
        // });

        // app.use(middlewareA);
        // app.use(middlewareB);
        // app.use(middlewareC);
        //  三种状态
        // const PENDING = "pending";
        // const RESOLVED = "resolved";
        // const REJECTED = "rejected";
        // // promise 接收一个函数参数，该函数会立即执行
        // function myPromise() {
        //     let _this = this;
        //     _this.currentStatus = PENDING;
        //     _this.value = undefined;
        //     _this.resolvedCallback = [];
        //     _this.rejectedCallback = [];
        //     _this.resolve = function (value) {
        //         if (value instanceof myPromise) {
        //             return value.then(_this.resolve, _this.reject);
        //         } else {
        //             //保证异步执行
        //             setTimeout(() => {
        //                 if (_this.currentStatus === PENDING) {
        //                     _this.currentStatus = RESOLVED;
        //                     _this.value = value;
        //                     _this.resolvedCallback.forEach((cb) => { cb() })
        //                     //按顺序执行
        //                 }
        //             })
        //         }
        //     }
        //     _this.reject = function (reason) {
        //         //保证异步
        //         setTimeout(() => {
        //             if (_this.currentStatus === PENDING) {
        //                 _this.currentStatus = REJECTED;
        //                 _this.value = reason;
        //                 _this.rejectedCallback.forEach((cb) => { cb() })
        //             }
        //         });
        //     }
        //     // 用于保存 then 中的回调，只有当 promise
        //     // 状态为 pending 时才会缓存，并且每个实例至多缓存一个
        // }
        // myPromise.prototype.then = function (onResolved, onRejected) {
        //     var self = this;
        //     //then必须返回新的promise
        //     var newPromise;
        //     //透传
        //     onResolved = typeof onResolved === 'function' ? onResolved : v => v;
        //     onRejected = typeof onRejected === 'function' ? onRejected : r => r;
        //     if (self.currentStatus === RESOLVED) {
        //         return (newPromise = new myPromise((resolve, reject) => {
        //             setTimeout(() => {
        //                 try {
        //                     var x = onResolved(self.value)
        //                     resolutionProcedure(newPromise, x, resolve, reject)
        //                 } catch (reason) {
        //                     reject(reason)
        //                 }
        //             })
        //         }))
        //     }
        //     if (self.currentStatus === REJECTED) {
        //         return (newPromise = new myPromise((resolve, reject) => {
        //             setTimeout(() => {
        //                 try {
        //                     var x = onRejected(self.value)
        //                     resolutionProcedure(newPromise, x, resolve, reject)
        //                 } catch (reason) {
        //                     reject(reason)
        //                 }
        //             })
        //         }))
        //     }
        //     if (self.currentStatus === PENDING) {
        //         return (newPromise = new myPromise((resolve, reject) => {
        //             self.resolvedCallback.push(() => {
        //                 try {
        //                     var x = onResolved(self.value)
        //                     resolutionProcedure(newPromise, x, resolve, reject)
        //                 } catch (reason) {
        //                     reject(reason);
        //                 }
        //             })
        //         }))
        //     }
        // }
        // //等待执行函数，判断边界条件
        // function resolutionProcedure(newPromise,x,resolve,reject) {
        //     if(x === newPromise){
        //         return reject(new TypeError("ERROR")) 
        //     }
        //     if(x instanceof myPromise){
        //         if(x.currentStatus===PENDING){
        //             x.then((value)=>{
        //                 resolutionProcedure(newPromise,value,resolve,reject)
        //             },reject)
        //         }else{
        //             x.then(resolve,reject)
        //         }
        //     }else{
        //         return;
        //     }
        // }
        // function ins(left,right){
        //     let prototype=right.prototype;
        //     let left=left.__proto__;
        //     while(true){
        //         if(left===null){
        //             return false;
        //         }else if(prototype===left){
        //             return true;
        //         }
        //         left=left.__proto__;
        //     }

        // }
        //    console.log( ('abc345efgabcab').replace(/\d/g,'[$&]'));

        // function createNew(newObj) {
        //     let obj = Object.create(newObj.prototype);
        //     let args = Array.prototype.slice(arguments, 1);
        //     let result = obj.apply(newObj, args);
        //     return (typeof result==="object"?result:obj);
        // }
    </script>
    <!-- <script src="bigInt.js">
</script> -->
    <!-- <script src="doujie.js"></script> -->
    <!-- <script src="./moveable.js"></script> -->
    <!-- <script>
    function minusAward(line){
    // let line=readline();
    let count=line[0];
    let n;
    let arr=[];
    for(var i=1;i<count;i++){
        n=line[i*2];
        arr=line[i*2+1];
        console.log(awardNum(n,arr))
    }
}
//最小的奖品数
function awardNum(n,arr){
    var awardN=0;
    if(all(n,arr)){
        arr.forEach((item)=>{
          awardN+=item/(parseInt(all(n,arr)));
        })
    }else{
        arr.forEach((item)=>{
            awardN+=item;
        })
    }
    return awardN;
    
}
//找公因数
function all(n,arr){
    var maxNum=0;
    for(var i=0;i<n;i++){
        if(arr[i]>maxNum){
            maxNum=arr[i]
        }
    }
    var count=0;
    var m=0;
    for(var i=2;i<Math.sqrt(maxNum);i++){
        for(var j=0;j<arr.length;j++){
            if(arr[j]%i===0){
                count++;
                if(i>m){
                    m=i;
                }
            }
        }
        if(count===arr.length-1){
                return m;
            }else{
                return false;
            }
    }
    
}
minusAward(); -->
    <!-- </script> -->
    <!-- <script src="sum.js">
    </script> -->
    <!-- <script src="request.js"></script>
     -->
    <script>
        //     let arr = [1, 2, 3, 4, 5, 6];
        //     Array.prototype.remove = function (index) {
        //         this.splice(index, 1);
        //         return this;
        //     }
        //    console.log( arr.remove(3));
        // var name = "one";
        // var User =
        //     function () {
                
        //         this.name = "two";
        //         console.log(this.name)
        //     }
            
        // var obj =
        //     User();
        // console.log(name);

    </script>
    <!-- <script src="diff.js"></script> -->
    <script src="tran.js"></script>
</body>

</html>